<!-- build time:Sun Nov 20 2022 20:50:18 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hello" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hello" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="Hello" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://example.com/2022/05/12/pwn%20college%20%E8%BD%AC/"><title>pwncollege | li0il Shoka = Hello</title><meta name="generator" content="Hexo 6.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">pwncollege</h1><div class="meta"><span class="item" title="Created: 2022-05-12 18:08:43"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-05-12T18:08:43+08:00">2022-05-12</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">li0il Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciundwu5j20zk0m8n9e.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://example.com/2022/05/12/pwn%20college%20%E8%BD%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="lxy"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><div class="body md" itemprop="articleBody"><h1 id="0x2关卡记录"><a class="anchor" href="#0x2关卡记录">#</a> 0x2. 关卡记录</h1><h2 id="1level1~3密码传参"><a class="anchor" href="#1level1~3密码传参">#</a> 1.level1~3：密码传参</h2><p>前三关是传密码，第 1 关无密码，第二关运行后输入密码，第 3 关通过参数传密码。</p><p>因为密码在提示中写了，认识英语就知道密码了。</p><h2 id="2level47环境变量"><a class="anchor" href="#2level47环境变量">#</a> 2.level4，7：环境变量</h2><p>4 要求新增一个环境变量；</p><p>7 要求设置空环境变量；</p><p>总而言之都用一条命令：</p><pre><code>env -i &lt;program&gt;
</code></pre><p>便可以重新设定环境变量运行程序，7 的要求只需要不加环境变量参数即可，当然 4 也可以使用 export 完成吧。</p><p>这些知识在挑战上方的视频中都有讲解，不明白可以看看。</p><h2 id="3level56重定向"><a class="anchor" href="#3level56重定向">#</a> 3.level5，6：重定向</h2><p>5 重定向输入；</p><p>6 重定向输出。</p><p>使用大小于号就可以重定向输入和输出。</p><h2 id="4level8~14shell脚本"><a class="anchor" href="#4level8~14shell脚本">#</a> 4.level8~14：shell 脚本</h2><p>8 创建一个 shell 脚本运行。</p><p>9 除了创建脚本还需要输入密码。</p><p>10 除了创建脚本还需要传参密码。</p><p>11 除了创建脚本还需要新增环境变量。</p><p>12 除了创建脚本还需要输入重定向。</p><p>13 除了创建脚本还需要输出重定向。</p><p>14 除了创建脚本还需要空环境变量。</p><h2 id="5level15~21ipython"><a class="anchor" href="#5level15~21ipython">#</a> 5.level15~21：ipython</h2><p>15 要求用 ipython 来运行程序，但是直接进入 ipython 后用命令：</p><pre><code>run checker.py
</code></pre><p>来运行检测脚本会因为权限不足无法读取 /flag。。。</p><p>然后发现可以用命令：</p><pre><code>import subprocess;subprocess.run([&quot;./embryoio_level15&quot;])
</code></pre><p>来运行得到 flag。</p><p>16 要求用 ipython 运行，还有输入密码（好家伙，又来一轮）</p><p>17 传参密码；18 新增环境变量；19 输入重定向；20 输出重定向；21 空环境</p><h2 id="6level22~28python脚本"><a class="anchor" href="#6level22~28python脚本">#</a> 6.level22~28：python 脚本</h2><p>嗯，老套路。</p><h2 id="7level29~35c语言"><a class="anchor" href="#7level29~35c语言">#</a> 7.level29~35：c 语言</h2><p>这个给了很多提示，大概是因为这个更涉及原理吧，原文如下：</p><pre><code>[INFO] This challenge will now perform a bunch of checks.
[INFO] If you pass these checks, you will receive the flag.
[TEST] Performing checks on the parent process of this process.
[TEST] Checking to make sure that the process is a custom binary that you created by compiling a C program
[TEST] that you wrote. Make sure your C program has a function called 'pwncollege' in it --- otherwise,
[TEST] it won't pass the checks.
[HINT] If this is a check for the *parent* process, keep in mind that the exec() family of system calls
[HINT] does NOT result in a parent-child relationship. The exec()ed process simply replaces the exec()ing
[HINT] process. Parent-child relationships are created when a process fork()s off a child-copy of itself,
[HINT] and the child-copy can then execve() a process that will be the new child. If we're checking for a
[HINT] parent process, that's how you make that relationship.
[INFO] The executable that we are checking is: /usr/bin/bash.
[HINT] One frequent cause of the executable unexpectedly being a shell or docker-init is that your
[HINT] parent process terminated before this check was run. This happens when your parent process launches
[HINT] the child but does not wait on it! Look into the waitpid() system call to wait on the child!

[HINT] Another frequent cause is the use of system() or popen() to execute the challenge. Both will actually
[HINT] execute a shell that will then execute the challenge, so the parent of the challenge will be that
[HINT] shell, rather than your program. You must use fork() and one of the exec family of functions (execve(),
[HINT] execl(), etc).
[FAIL] You did not satisfy all the execution requirements.
[FAIL] Specifically, you must fix the following issue:
[FAIL]    The process must be your own program in your own home directory.
</code></pre><p>总之，总结一下看出来的知识点：</p><ol><li>对父进程的检测需要使用 exec () 系列的函数，因为 system () 或 popen () 函数都会执行一个 shell，然后用 shell 来执行，所以此时父进程为 shell（测试后是 dash），而不是你的程序。</li><li>而 exec () 只是替换掉正在 exec () 的进程，当用 fork () 函数时子进程调用 exec () 系列函数杀死自己的子进程副本的时候就会建立与当前主进程的父子关系。</li><li>当一个父亲创建了一个孩子但没有等它结束就自己结束的话就可能造成系统异常，查询 waitpid () 的使用来等待孩子进程。</li></ol><p>另外查询了一下，说是 exec 系统调用，实际上在 Linux 中，并不存在一个 exec () 的函数形式，exec 指的是一组函数，一共有 6 个，分别是：</p><pre><code>#include &lt;unistd.h&gt;
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
</code></pre><p>然后整理了一下基本使用：</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void pwncollege(char* argv[],char *env[])&#123;
    execve(&quot;/challenge/embryoio_level29&quot;,argv,env);//使用exec系列函数执行时不会改变新进程的父亲，相当于只是将当前进&gt;程替换掉了
    return ;
&#125;

int main(int argc,char* argv[],char* env[])&#123;
    pid_t fpid;

    fpid=fork();//fork()执行之后，会复制一个基本一样的进程作为子进程，然后两个进程会分别执行后面的代码
    if(fpid&lt;0)//如果fpid为-1，说明fork失败
            printf(&quot;error in fork!\n&quot;);
    else if (fpid==0)&#123;//成功则会出现两个进程，fpid==0的是子进程
            printf(&quot;我是子进程\n&quot;);
            pwncollege(argv,env);
    &#125;
    else&#123;//fpid==1的是父进程
            printf(&quot;我是父进程\n&quot;);
            wait(NULL);
    &#125;
    return 0;
&#125;
</code></pre><p>然后又是一次轮回。</p><p>注意，设定参数数组时，第一个不是参数而是文件名，而且最后需要加 NULL（因为数组最后一位需要为 \0 吧。），这两个任意错了一步就会导致运行子进程失败：</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void pwncollege(char* argv[],char *env[])&#123;
    char *newargv[]=&#123;&quot;embryoio_level31&quot;,&quot;scfxabffgf&quot;,NULL&#125;;
    execve(&quot;/challenge/embryoio_level31&quot;,newargv,env);//使用exec系列函数执行时不会改变新进程的父亲，相当于只是将当前&gt;进程替换掉了
    return ;
&#125;

int main(int argc,char* argv[],char* env[])&#123;
    pid_t fpid;

    fpid=fork();//fork()执行之后，会复制一个基本一样的进程作为子进程，然后两个进程会分别执行后面的代码
    if(fpid&lt;0)//如果fpid为-1，说明fork失败
            printf(&quot;error in fork!\n&quot;);
    else if (fpid==0)&#123;//成功则会出现两个进程，fpid==0的是子进程
            printf(&quot;我是子进程\n&quot;);
            pwncollege(argv,env);
    &#125;
    else&#123;//fpid==1的是父进程
            printf(&quot;我是父进程\n&quot;);
            wait(NULL);
    &#125;
    return 0;
&#125;
</code></pre><h2 id="8level36~65管道"><a class="anchor" href="#8level36~65管道">#</a> 8.level36~65：管道</h2><p>36： <code>/challenge/embryoio_level36 | cat</code> 37 关:grep</p><p>38 关:sed</p><p>39 关:rev</p><p>40 关：输入管道符</p><p>41 关:rev 输入</p><p>42~47:shell 脚本 + 管道，然后依次 grep,sed，rev，输入，rev 输入</p><p>48~53：ipython + 管道（找了好久教程结果发现其实和重定向操作一样，就是将输入流和输出流互相绑定一下，如下：</p><pre><code>import subprocess
p1 = subprocess.Popen([&quot;/challenge/embryoio_level48&quot;], stdout=subprocess.PIPE)#只能用Popen，其他会失败
p2 = subprocess.Popen([&quot;cat&quot;], stdin=p1.stdout, stdout=subprocess.PIPE)
output = p2.communicate()[0]
print(output)
</code></pre><p>据提示说，pwntools 也能进行这样的管道操作，可是我实在没找到，process () 和 subprocess 中的 run () 一样，都不能进行这样的操作，之后再说吧。）</p><p>之后就是一轮新的循环了，没啥好说的。</p><p>54~59：python 脚本 + 管道。</p><p>60~65：c 语言 + 管道。（其中管道和父进程直接相连通了，所以直接操作父进程即可）</p><h2 id="9level66~67find命令exec"><a class="anchor" href="#9level66~67find命令exec">#</a> 9.level66~67：find 命令 exec</h2><p>66 是考 find 命令用 - exec 和 - ok 参数运行脚本：</p><pre><code>find . -name &quot;4*&quot; -exec /challenge/embryoio_level66 \;
</code></pre><p>然后 67 让输入参数密码。</p><h2 id="10level68~73shell脚本杂项"><a class="anchor" href="#10level68~73shell脚本杂项">#</a> 10.level68~73：shell 脚本杂项</h2><p>68 让运行时以 shell 脚本方式，并且在第 284 个参数输入密码，一行搞定：</p><pre><code>/challenge/embryoio_level* `printf ' nzfslgudsh%0.s' &#123;1..284&#125;`
</code></pre><p>69 让空参数，这咋弄，不会啊。</p><p>找了找方案，一种思路是加很多很多参数，让其参数列表 “爆表”，结果其实不行，linux 考虑到了这方面，经实验，参数到达 65529 个时就会报参数太长的错误（为啥是这个数字我也不知道）。</p><p>另一种思路就还是利用 c 语言中的 exec () 系列函数来执行进程，此时可以设置参数序列为空，问题在于题目要求是在 shell 脚本中执行，而且需要在 bash 或 sh 环境（经尝试用 system () 函数是用的 dash 环境）。</p><p>实在没办法了网上也没教程，我就仔细看了下它的 checker.py 源码是怎么写的，发现它的判断有点草率，如下：</p><pre><code>def check_bash(process):
    print(&quot;[TEST] Checking to make sure the process is the bash shell. If this is a check for the parent process, then,&quot;)
    print(&quot;[TEST] most likely, this is what you do by default anyways, but we'll check just in case...&quot;)
    check_exe_basename(process, 'bash')
    assert len(process.cmdline()) == 1, f&quot;The shell process must be running in its default, interactive mode (/bin/bash with no commandline arguments). Your commandline arguments are: &#123;process.cmdline()&#125;&quot;

def check_shellscript(process):
    print(&quot;[TEST] Checking to make sure the process is a non-interactive shell script.&quot;)

    assert os.path.basename(process.exe()) in [ 'sh', 'bash' ], f&quot;Process interpreter must be 'sh' or 'bash'. Yours is: &#123;os.path.basename(process.exe())&#125;&quot;
    assert len(process.cmdline()) == 2 and process.cmdline()[1].endswith(&quot;.sh&quot;), f&quot;The shell process must be executing a shell script that you wrote like this: `bash my_script.sh`&quot;
</code></pre><p>这两个判断其实只是检测了一下命令执行的文件名，第一个 bash 检测就是检测运行的程序名为 bash 即可，第二个检测是 bash 加一个结尾为 <code>.sh</code> 的参数即可，所以我就把自己编写的 c 语言程序改名为 bash，然后加个参数不使用即可，具体操作如下：</p><p>c 源码：</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void pwncollege(char* argv[],char *env[])&#123;
        char *newenv[]=&#123;NULL&#125;;
        execve(&quot;/challenge/embryoio_level69&quot;,newenv,env);//使用exec系列函数执行时不会改变新进程的父亲，相当于只是将当前 进程替换掉了
        return ;
&#125;

int main(int argc,char* argv[],char* env[])&#123;
        pid_t fpid;

        fpid=fork();//fork()执行之后，会复制一个基本一样的进程作为子进程，然后两个进程会分别执行后面的代码
        if(fpid&lt;0)//如果fpid为-1，说明fork失败
                printf(&quot;error in fork!\n&quot;);
        else if (fpid==0)&#123;//成功则会出现两个进程，fpid==0的是子进程
                printf(&quot;我是子进程\n&quot;);
                pwncollege(argv,env);
        &#125;
        else&#123;//fpid==1的是父进程
                printf(&quot;我是父进程\n&quot;);
                wait(NULL);
        &#125;
        return 0;
&#125;
</code></pre><p>然后改名运行得到 flag：</p><pre><code>#改名：
gcc test.c -o bash
#运行，随便加个结尾为.sh的参数，实际并未使用：
./bash a.sh
</code></pre><p>70：env</p><p>71：多参数 + env</p><p>72：重定向 + 临时文件夹</p><p>73：要求主进程和子进程路径不同，不知道为啥一直不能成功。</p><p><strong>失败的方案：</strong></p><pre><code>echo &quot;这是主进程&quot;
pwd
cd;bash script.sh &amp;
sleep 3
echo &quot;这是子进程&quot;
pwd
/challenge/e*
echo &quot;这是主进程&quot;

echo &quot;子进程开始&quot;;cd /challenge;./e* &amp;

echo &quot;主进程开始等待&quot;;sleep 3;echo &quot;主进程结束&quot;
</code></pre><p><strong>成功方案：</strong></p><p>用了和上面那个一样的思路，shell 脚本中不容易显式的创建一个子进程或者新进程，就用 c 语言创建一个子进程来起作用，如下：</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void pwncollege(char* argv[],char *env[])&#123;
        char *newenv[]=&#123;&quot;embryoio_level65&quot;,NULL&#125;;
        chdir(&quot;/tmp/coooni&quot;);
        printf(&quot;current working directory: %s\n&quot;, getcwd(NULL, NULL));
        execve(&quot;/challenge/embryoio_level73&quot;,argv,env);//使用exec系列函数执行时不会改变新进程的父亲，相当于只是将当前进 程替换掉了
        return ;
&#125;

int main(int argc,char* argv[],char* env[])&#123;
        pid_t fpid;

        fpid=fork();//fork()执行之后，会复制一个基本一样的进程作为子进程，然后两个进程会分别执行后面的代码
        if(fpid&lt;0)//如果fpid为-1，说明fork失败
                printf(&quot;error in fork!\n&quot;);
        else if (fpid==0)&#123;//成功则会出现两个进程，fpid==0的是子进程
                printf(&quot;我是子进程\n&quot;);
                pwncollege(argv,env);
        &#125;
        else&#123;//fpid==1的是父进程
                printf(&quot;我是父进程\n&quot;);
                wait(NULL);
        &#125;
        return 0;
&#125;
</code></pre><h2 id="11level74~79python脚本杂项"><a class="anchor" href="#11level74~79python脚本杂项">#</a> 11.level74~79：python 脚本杂项</h2><p>74：让第 264 个参数为密码</p><p>75：要求空参数，我尝试了 os.execve 和 os.execvp，发现它底层的 os.execv () 要求参数二不能为空，和 c 语言的要求不太一样，就很无语。</p><p>所以故技重施，假冒 python 的 c 程序，但是执行报了一个很让人无语的检测失败：</p><pre><code>[FAIL]    Executable must be 'python'. Yours is: python
</code></pre><p>这不一样嘛！唉，还得看源码：</p><pre><code>def check_exe_basename(process, basename):
    print(f&quot;[INFO] The process' executable is &#123;process.exe()&#125;.&quot;)
    if os.path.basename(process.exe()) == &quot;docker-init&quot;:
        print(&quot;[WARN] This process is the initialization process of your docker container (aka PID 1).&quot;)
        print(&quot;[WARN] When the parent of a process terminates, that process is 'reparented' to PID 1.&quot;)
        print(&quot;[WARN] So, the likely situation here is that your parent process terminated before&quot;)
        print(&quot;[WARN] waiting on the child. Go fix that :-). Look into waitpid() in C, process.wait() for&quot;)
        print(&quot;[WARN] pwntools, or Popen.wait() for subprocess.&quot;)
    else:
        print(&quot;[INFO] This might be different than expected because of symbolic links (for example, from /usr/bin/python to /usr/bin/python3 to /usr/bin/python3.8).&quot;)

    actual_basename = os.path.basename(os.path.realpath(shutil.which(basename)))
    print(f&quot;[INFO] To pass the checks, the executable must be &#123;actual_basename&#125;.&quot;)
    assert os.path.basename(process.exe()) == actual_basename, f&quot;Executable must be '&#123;basename&#125;'. Yours is: &#123;os.path.basename(process.exe())&#125;&quot;

def check_python(process):
    print(&quot;[TEST] We will now check that that the process is a non-interactive python instance (i.e., an executing python script).&quot;)
    check_exe_basename(process, 'python')
    assert len(process.cmdline()) == 2 and process.cmdline()[1].endswith(&quot;.py&quot;), f&quot;The python process must be executing a python script that you wrote like this: `python my_script.py`&quot;
</code></pre><p>额，看来问题出在这个 <code>actual_basename</code> 上了，人家查的是实际的解析器名称，查一下：</p><pre><code>hacker@embryoio_level75:~$ ls -l /bin/python
lrwxrwxrwx 1 root root 7 Apr 15  2020 /bin/python -&gt; python3
hacker@embryoio_level75:~$ ls -l /bin/python3
lrwxrwxrwx 1 root root 9 Mar 13  2020 /bin/python3 -&gt; python3.8
hacker@embryoio_level75:~$ ls -l /bin/python3.8
-rwxr-xr-x 1 root root 5490488 Sep 28 16:10 /bin/python3.8
</code></pre><p>果然，把程序名改为 python3.8 就通过了。</p><p>76：修改环境变量，这个 subprocess.run 就有参数可以指定。</p><p>77：参数密码 + 环境变量</p><p>78：输入重定向 + 临时文件夹</p><p>79：临时文件夹 + 父子进程工作目录不同</p><h2 id="12level80~85子进程杂项"><a class="anchor" href="#12level80~85子进程杂项">#</a> 12.level80~85：子进程杂项</h2><p>80：c 程序子进程 + 参数设置</p><p>81：空参数</p><p>82：环境变量</p><p>83：参数设置 + 环境变量</p><p>84：工作路径 + 输入重定向</p><p>85：工作路径 + 父子进程工作路径不同</p><h2 id="13level86~87数据交互"><a class="anchor" href="#13level86~87数据交互">#</a> 13.level86~87：数据交互</h2><p>86：shell 脚本 + 数据交互</p><p>87：shell 脚本 + 5 个数据交互（简单运算）</p><h2 id="14level88~89改变argv0"><a class="anchor" href="#14level88~89改变argv0">#</a> 14.level88~89：改变 argv [0]</h2><p>88：shell 脚本 + 要求改变 argv [0] 的值，没办法，再次采用魔道打法</p><p>89：shell 脚本 + 要求改变 argv [0] 的值</p><p>我正纳闷为啥要重复考这个，忽然发现人家给提示了！！对嘛，不然我只能一招吃遍天下了：</p><pre><code>argv[0] is passed into the execve() system call *separately* from the program path to execute.This means that it does not have to be the same as the program path, and that you can actually control it. This is done differently for different methods of execution. For example, in C, you simply need to pass in a different argv[0]. Bash has several ways to do it, but one way is to use a combination of a symbolic link (e.g., the `ln -s` command) and the PATH environment variable.
</code></pre><p>翻译版本：</p><pre><code>argv[0]从要执行的程序路径分别传递到execve（）系统调用*中。这意味着它不必与程序路径相同，您可以实际控制它。这对于不同的执行方法是不同的。例如，在C中，您只需要传入不同的argv[0]。Bash有几种方法可以做到这一点，但其中一种方法是使用符号链接（例如，`ln -s`命令）和PATH环境变量的组合。
</code></pre><p>what！好像很简单，我之前一直想复杂了吗？</p><p>操作如下：</p><pre><code>#在本目录建立软链接：
ln -s /challenge/embryoio_level89 ydntbk

#将当前目录作为首个PATH变量
export PATH=.:$PATH
echo &quot;ydntbk&quot; &gt; script.sh
bash script.sh
</code></pre><p>耶！学到了，不过它说还有几种办法不知道是什么，另外在 shell 脚本中将参数数目变为空真的有可能吗。。</p><h2 id="15level90~93命名管道fifo"><a class="anchor" href="#15level90~93命名管道fifo">#</a> 15.level90~93：命名管道 fifo</h2><p>90：让使用 FIFO，我一直以为 mkfifo 和管道符一样呢，原来有区别啊。</p><p>总而言之说一下我的理解，也懒得找官方解释。</p><p>简单来说就是一个有实体的管道，创建时会以文件的形式出现在当前目录中，好像是单工通信，只能由一方传给另一方，而且如果没有消费者，生产者会阻塞等待，所以我们在运行时需要并发运行两个进程，不然会阻塞。</p><p>下面放一下我的通关过程：</p><pre><code>#创建FIFO通道：
mkfifo test
#写入shell脚本，是读方
echo '/challenge/embryoio_level* &lt; test' &gt; script.sh
#同时运行读写进程，所以需要用算数运算符|或&amp;进行连接，注意不能用分号;，因为那样是串行执行：
echo vctmlgmx &gt; test | bash script.sh
</code></pre><p>91：fifo 写重定向</p><p>92：fifo 读写重定向（需要 2 个通道）</p><p>93：要求写个可交互式的双通道，写了如下 shell 脚本：</p><pre><code>/challenge/embryoio_level* &lt; t1 &gt; t2 &amp;
cat &lt; t2 &amp;
cat &gt; t1
</code></pre><h2 id="16level94绑定文件描述符exec"><a class="anchor" href="#16level94绑定文件描述符exec">#</a> 16.level94：绑定文件描述符 exec</h2><p>94：要求绑定 235 号文件描述符，想到 exec 命令可以绑定，通过代码如下：</p><pre><code>echo 'exec 235&lt;t1;/challenge/embryoio_level*' &gt; script.sh
bash script.sh &amp; cat &gt; t1
</code></pre><h2 id="17level95~96简单"><a class="anchor" href="#17level95~96简单">#</a> 17.level95~96：简单</h2><p>95，96：shell 脚本 + 输入密码（这么简单不知道是什么鬼，也没有提示）</p><h2 id="18level97~98信号signal"><a class="anchor" href="#18level97~98信号signal">#</a> 18.level97~98：信号 signal</h2><p>97：要求给它发送指定信号，不知道怎么就过了（哦，它估计让发送一个 SIGINT 的信号，ctrl+c 正好是）</p><p>98：要求按顺序给它发送 5 个信号，这次了解了下 linux 下信号的知识，知道了利用 kill 命令发送信号，如下通关代码：</p><pre><code>bash script.sh &amp;
#回显：[TEST] You must send me (PID 90) the following signals, in exactly this order: ['SIGINT', 'SIGHUP', 'SIGHUP', 'SIGHUP', 'SIGHUP']
kill -SIGINT 90
kill -SIGHUP 90
kill -SIGHUP 90
kill -SIGHUP 90
kill -SIGHUP 90
</code></pre><h2 id="19level99~111python脚本杂项2"><a class="anchor" href="#19level99~111python脚本杂项2">#</a> 19.level99~111：python 脚本杂项 2</h2><p>99，100：python 脚本 + 简单运算</p><p>101，102：修改 argv [0]</p><p>103，104，105：fifo</p><p>106：fifo + 简单运算</p><p>107：设定 125 文件描述符</p><p>想要学上面在 shell 脚本中使用的方法，然后遇到了很多坑才写出来，如下：</p><p>p.py 内容：</p><pre><code>import subprocess
import os
f=open(&quot;./t1&quot;)#打开fifo通道，因为没有写端，所以打开时会阻塞
f2=os.dup2(f.fileno(),125)#用os.dup2复制通道的文件描述符到125号文件描述符，python3.4以后文件描述符是默认子进程可共享的
print(&quot;新的文件描述符：%s&quot;%f2)
print(&quot;可继承位：%s&quot;%os.get_inheritable(f2))#检验是否真的子进程可继承，真的为True
#print(&quot;文件内容：%s&quot;%f2.read())
#print(f.read())
argv=[&quot;/challenge/embryoio_level107&quot;]
p=subprocess.Popen(argv,pass_fds=[0,1,2,125])#重点来了！子进程要想获取到这些主进程的文件描述符，必须要在调用Popen时设定pass_fds数组的值，不然无法获取，这里卡了好久。。。。
p.wait()#最后一个坑，主进程需要阻塞等待子进程，不然它的父亲会变成它爷爷，哈哈
</code></pre><p>顺带一提，pwntools 子进程想要使用先前绑定的文件描述符需要在 process 时设定参数 ** <code>close_fds=False</code> **，默认是关闭了除 0~2 的所有文件描述符的。</p><p>调用：</p><pre><code>#因为打开命名通道时会阻塞，所以把它放到后台运行
python p.py &amp; cat &gt; t1
</code></pre><p>不过突然想到好像也不用什么通道，直接把标准输入 0 给复制过去不就行了（嗯，试了一下确实可以）。</p><p>108，109：输入密码</p><p>110，111：发送信号</p><h2 id="20level112~124c语言杂项"><a class="anchor" href="#20level112~124c语言杂项">#</a> 20.level112~124：c 语言杂项</h2><p>112，113：c 程序 + 简单运算</p><p>114，115：设置 argv [0]</p><p>和上面一样的循环。</p><h2 id="21level125~139交互脚本编写"><a class="anchor" href="#21level125~139交互脚本编写">#</a> 21.level125~139：交互脚本编写</h2><p>125：shell 脚本，它让运算 50 次，很明显是让写脚本了。</p><p>但是利用 linux 原生的工具进行操作我不太熟悉，更何况这个一般会 python 即可，就用 python 写吧：</p><pre><code>#!/usr/bin/python3
from pwn import *

p=process(&quot;/challenge/embryoio_level125&quot;)
for i in range(50):
    #print(p.recvline())
    print(p.recvuntil(b&quot;:\n&quot;))
    s=p.recvline()
    print(s)
    tmp=eval(s)
    print(tmp)
    p.sendline(b&quot;%d&quot;%tmp)

print(p.recvall())
</code></pre><p>结果发现不行，因为人家要求解析器为 bash，所以不能直接执行 python。</p><p>我又换了一种思路，bash 脚本虽然不会写，但是写个 python 运算器脚本，和原进程进行交互不就行了，所以写了如下一个运算器：</p><p>t.py 源码：</p><pre><code>f1=open(&quot;./t1&quot;,&quot;rb&quot;)#利用t1通道进行输入数据
f2=open(&quot;./t2&quot;,&quot;wb&quot;)#t2通道输出数据
for i in range(200):
    s=f1.readline()
    print(s)
    index=s.find(b&quot;: &quot;)#如果有这个标志说明这一行是需要运算的
    if index != -1:
        t1=s[index+2:-1]
        print(t1)
        t2=eval(t1)#运算得到结果
        print(b&quot;%d\n&quot;%t2)
        f2.write(b&quot;%d\n&quot;%t2)#写入t2传回结果
        f2.flush()#缓冲区清空是个大坑啊，我又栽这了好久。。。不加这一行原程序得不到我们的运行结果

f1.close()
f2.close()
</code></pre><p>script.sh 内容：</p><pre><code>#调试用命令：
python t.py &amp; cat &lt; t2 &amp; cat &gt; t1
/challenge/embryoio_level* &gt; t1 &lt; t2 &amp; cat &lt; t1 &amp; cat &gt; t2
/challenge/embryoio_level* &gt; t1 &lt; t2 &amp; python t.py &amp; cat &gt; t2

#通关命令：
/challenge/embryoio_level* &gt; t1 &lt; t2 &amp; python t.py
</code></pre><p>126：要输入 500 个答案，哈哈，这次运算也变得特别复杂，把输入给过滤掉可能能运算快点。</p><p>稍微升级了下上面的脚本：</p><pre><code>f1=open(&quot;./t1&quot;,&quot;rb&quot;)#利用t1通道进行输入数据
f2=open(&quot;./t2&quot;,&quot;wb&quot;)#t2通道输出数据
sum=0
for i in range(3000):
    s=f1.readline()
    if sum &gt;=500:
        print(s)
        print(f1.read())
        break
    index=s.find(b&quot;: &quot;)#如果有这个标志说明这一行是需要运算的
    if index != -1:
        sum+=1
        t1=s[index+2:-1]
        #print(t1)
        t2=eval(t1)#运算得到结果
        print(&quot;%d : %d&quot;%(sum,t2))
        f2.write(b&quot;%d\n&quot;%t2)#写入t2传回结果
        f2.flush()#缓冲区清空是个大坑啊，我又栽这了好久。。。不加这一行原程序得不到我们的运行结果

f1.close()
f2.close()

</code></pre><p>127：让发送给进程 50 个指定信号，很明显又是脚本编写。</p><p>但是问题在于那个程序直接输入进 fifo 命名管道里好像用了全缓冲区，导致我无论如何也无法在运行的同时获取到提示，这咋弄啊。（后来发现好像不是缓冲区的问题，看了下 checker.py 的源码，在执行这个挑战的时候会截取所有传到这个进程的信号进行处理，而使用管道的话管道好像也需要使用信号，就导致获取不到数据？好像也不对啊，在监听信号之前也有一部分输出的，但是那部分的输出也看不到，这有点说不通。）</p><p>冥思苦想了好长时间，首先想到另外一个魔道打法（我怎么总是搞这些奇奇怪怪的打法，误）。</p><p>一、把 python3.8 复制过来，改名为 bash，这样就可以骗过 checker.py 说解析器是 bash 了</p><p>当然这个方法上面的几道题也能用。</p><p>这样做的好处是，虽然我不会处理怎么让程序运行时输出到命名管道里怎么无缓冲区输出，但是利用 pwntools 或者 subprocess 就没有这个烦恼了啊，然后只要将 python 脚本的后缀改为 sh 就能骗过检测了。</p><p>如下操作：</p><pre><code>cp /usr/bin/python3.8 bash
./bash 127.sh

</code></pre><p>127.sh 源码：</p><pre><code>from pwn import *
import os
import signal

sh=process(&quot;/challenge/embryoio_level127&quot;)
#print(sh.recvline())
#print(sh.recvline())
sh.recvuntil(b&quot;(PID &quot;)
pid=int(sh.recvuntil(b&quot;)&quot;)[:-1])
print(&quot;该程序的pid为%d&quot;%pid)
sh.recvuntil(b&quot;: &quot;)

s=sh.recvline()[:-1]
print(&quot;信号序列为&quot;)
print(s)
a=eval(s)
for i in range(len(a)):
	print(&quot;正在发送信号：%d&quot;%i)
	print(pid,eval(&quot;signal.&quot;+a[i]))
	os.kill(pid,eval(&quot;signal.&quot;+a[i]))
	sh.recvline()
	sh.recvline()
print(sh.recvall())

</code></pre><p>二、第二个想法是昨天查了查资料，说命名管道 fifo 其实可以控制阻塞输出和缓冲区大小，但是需要在 c 语言中调用 api，所以如果操控好的话说不定也能获取到信息。</p><p>128：猜都猜得出来，发送 500 个信号，直接用上面的脚本。</p><p>129：有点变态，要求我用 shell 脚本编写，并且控制它的输入流指向 cat，输出流也指向 cat，还要我算 50 个复杂运算。</p><p>所以我们只需要控制第一个 cat 的输入流和第二个 cat 的输出流即可。</p><p>测试脚本（ps：这个脚本对 127 的题不起作用，就很神奇）：</p><pre><code>f1=open(&quot;./t1&quot;,&quot;r&quot;)
f2=open(&quot;./t2&quot;,&quot;w&quot;)
while True:
    s=f1.readline()
    print(&quot;获取到了数据：&quot;)
    print(s)
f1.close()
f2.close()

</code></pre><p>通关脚本：</p><pre><code>f1=open(&quot;./t1&quot;,&quot;r&quot;)
f2=open(&quot;./t2&quot;,&quot;w&quot;)
count=0
for i in range(3000):
    if count &gt;= 50:
        print(f1.read(1024))
        break
    s=f1.readline()
    #print(&quot;获取到了数据：&quot;)
    print(s,end='')
    if &quot;: &quot; in s:
        count+=1
        index=s.find(&quot;: &quot;)
        a=s[index+2:-1]
        b=eval(a)
        print(b)
        f2.write(&quot;%d\n&quot;%b)
        f2.flush()

f1.close()
f2.close()

</code></pre><p>script.sh 内容：</p><pre><code>cat &lt; t2 | /challenge/embryoio_level* | cat &gt; t1 &amp;
python 129.py

</code></pre><p>130：用 python 脚本运算 50 次，直接用上面脚本</p><p>131：500 次</p><p>重复上面的。</p><p>然后 134 在管道上遇到了问题，然后研究了好长时间发现 python 可以直接利用 os.pipe () 创建一个 linux 的管道，真的是，白忙活了，不管怎么样学到了：</p><pre><code>import subprocess
import fcntl
import os

r1,w1=os.pipe()

p0 = subprocess.Popen([&quot;cat&quot;], stdin=subprocess.PIPE, stdout=w1)
#flags = fcntl.fcntl(p0.stdout, fcntl.F_GETFL)
#fcntl.fcntl(p0.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)#解为非阻塞

r2,w2=os.pipe()

p1 = subprocess.Popen([&quot;/challenge/embryoio_level134&quot;],stdin=r1, stdout=w2)
#flags = fcntl.fcntl(p1.stdout, fcntl.F_GETFL)
#fcntl.fcntl(p1.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)


p2 = subprocess.Popen([&quot;cat&quot;], stdin=r2, stdout=subprocess.PIPE)

#flags = fcntl.fcntl(p2.stdout, fcntl.F_GETFL)
#fcntl.fcntl(p2.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)

for i in range(50):
	s=''
	while True:
		s=p2.stdout.readline().decode()
		print(s,end=&quot;&quot;)
		if &quot;: &quot; in s or s==&quot;&quot;:
			break

	a=s[s.find(&quot;: &quot;)+2:-1]
	print(&quot;式子为%s&quot;%a)
	b=eval(a)
	print(&quot;答案为%d&quot;%b)
	p0.stdin.write(b&quot;%d\n&quot;%b)
	p0.stdin.flush()

for i in range(50):
	print(p2.stdout.readline().decode(),end=&quot;&quot;)

</code></pre><p>135 开始又是 c 语言的循环，因为 c 程序的子进程可以直接继承主进程的通道关系，所以类似于上面的 bash 时的脚本，直接交互即可。</p><p>但是在 137 时又遇到了上面那个问题，信号的脚本获取不到数据啊，只要一用通道就得不到它的数据了，不知道什么毛病。</p><p>这次想要浑水摸鱼好像有点不行，因为它除了要求用 c 程序运行以外，还要求 argv [0] 为空，这个我只能通过 c 程序来实现，python 的 os 库虽然也有 exec 系列函数，但是参数长度不能为空，没办法实现，就很神奇。</p><p>为啥就这个测试一旦使用通道就获取不到输出啊，只有结束运行之后才会出现显示结果。</p><p>（后来我觉得有点不对劲，为啥 c 程序运行就能通过 <code>argc==1</code> 的检测，而 python 代码不能通过，而且前面的 <code>argc==1</code> 应该不是检测 argv [0] 为空的意思，所以就自己实验了一下，发现之前果然是我理解错了，一直有个地方没理解对。</p><p>c 程序是编译程序，而 python 和 shell 脚本是脚本解释形语言，而脚本解释语言的执行则需要一个解析器来执行，这就是脚本开头需要设置一个如：</p><pre><code>#!/usr/bin/python
#!/bin/bash

</code></pre><p>这样的语句来指定解释器的地址。</p><p>而 checker.py 在检查的时候是这样检查的：</p><pre><code>len(psutil.Process(os.getpid()).cmdline())==1

</code></pre><p>而直接 <code>./test.py</code> 这样执行时， <code>psutil.Process(os.getpid()).cmdline()</code> 产生的序列是这样的：</p><pre><code>['/usr/bin/python', './test.py']

</code></pre><p>也就是说它在运行时会把解析器当做第一个参数来执行，这样序列长度就为 2 了，这就是我用 python 和 bash 脚本通过不了的原因。</p><p>解决办法也简单，既然直接执行必须调用解释器，那我打包之后再执行不就行了？</p><p>嗯，尝试了下，用 pyinstaller 包可以很轻易的打包好 python 脚本，但是问题在于，题目中的检测还有一层：它调用了 <code>/usr/bin/nm</code> 进行检测，要求有一个名为 pwncollege 的函数，而问题在于，用 pyinstaller 进行编译链接的时候，应该是把所有全局标志都去除了，导致用 nm 检测时没有标志，这就很无奈了。</p><p>）</p><p>（研究了下又有新发现，发现虽然用 <code>./a.out | cat</code> 这样获取不到输出，但是用 python 来：</p><pre><code>p=subprocess.Popen(&quot;./a.out&quot;,stdin=subprocess.PIPE,stdout=subprocess.PIPE)

</code></pre><p>却可以获取到输出，这就好说了，直接可以用上面的脚本改一下，把运行程序改成 c 程序即可：</p><pre><code>from pwn import *
import os
import signal

sh=process(&quot;./137.out&quot;)
#print(sh.recvline())
#print(sh.recvline())
sh.recvuntil(b&quot;(PID &quot;)
pid=int(sh.recvuntil(b&quot;)&quot;)[:-1])
print(&quot;该程序的pid为%d&quot;%pid)
sh.recvuntil(b&quot;: &quot;)

s=sh.recvline()[:-1]
print(&quot;信号序列为&quot;)
print(s)
a=eval(s)
for i in range(len(a)):
	print(&quot;正在发送信号：%d&quot;%i)
	print(pid,eval(&quot;signal.&quot;+a[i]))
	os.kill(pid,eval(&quot;signal.&quot;+a[i]))
	sh.recvline()
	sh.recvline()
print(sh.recvall())

</code></pre><p>呼，总算把这两个通关了，没想到成为难到我的最后两题。</p><p>）</p><p>139 也是运算 50 次，我基本上直接把 129.py 拿来使用了，但是有个检查比较奇怪，它要求主进程被 cat 运行，我新建了个名为 cat 的 bash，然后这样执行：</p><pre><code>cat &lt; t2 | env -i &quot;SHELL=./cat&quot; ./a.out | cat &gt; t1 &amp; python 139.py

</code></pre><p>就通过了，但是不太清楚是不是这样过的，也不知道它想考啥。</p><h2 id="22level140~142网络"><a class="anchor" href="#22level140~142网络">#</a> 22.level140~142：网络</h2><p>140 这道题感觉很奇怪，正常来做感觉不可能达成啊。</p><p>在运行题目的程序时，它在本地的 1166 端口开了一个服务，可以接收其他程序来的 tcp 连接。</p><p>问题在于，它会检测你是不是通过 shell 脚本来连接的客户端，除此之外它还要求解析器必须为 bash 或 sh。</p><p>问题在于，我在使用 netcat 进行访问时它会说解析器是 netcat，甚至我用这样：</p><pre><code>cat &lt; /dev/tcp/127.0.0.1/1166

</code></pre><p>来访问，它也会说解析器是 cat，无论在交互式环境执行还是 shell 脚本中。</p><p>这就导致我如果想让它解析器识别为 bash，必须在 shell 脚本中不依赖其他工具，直接访问到指定网络端口，但是不知道是不是我孤陋寡闻了，我不知道这样的方法也查不到。如果想要在 shell 脚本中访问网络，其实就是调用其他的工具进行执行啊，怎么可能只是利用 bash？</p><p>想不到方法的我只好又用了之前的方法，复制一个名为 bash 的 python3.8，在 140.sh 文件中写入 python 代码，用 python 写一个小网络连接器，这样就能满足它的所有条件了。</p><p>不知道它期待中的解法是怎么样的。</p><p>140.sh 源码：</p><pre><code>#!/usr/bin/env python
#encoding=utf-8

import socket
import threading
import time
from sys import argv,stdout,stderr,version_info

PY2 = True if version_info[0] == 2 else False
if PY2:
	input=raw_input
	cout=stdout
else:
	cout=stdout.buffer

def recvdata(conn):
	while not event.is_set():
		try:
			data=conn.recv(4096)
			if not data:
				stderr.write(&quot;客户端已断开连接\n&quot;)
				event.set()
				conn.close()
				break
			cout.write(data)
			stdout.flush()
		except Exception as e:
			stderr.write(str(e))
			conn.close()
			event.set()
			stderr.write(&quot;已断开连接\n&quot;)

def senddata(conn):
	try:
		if PY2:
			while not event.is_set():
				data=input()
				if not event.is_set():
					conn.sendall(data+b'\n')
		else:
			while not event.is_set():
				data=input()
				if not event.is_set():
					conn.sendall(data.encode()+b'\n')
	except Exception as e:
		stderr.write(e)
		conn.close()
		event.set()
		stderr.write(&quot;发送数据错误！\n&quot;)

def listener(host,port):
	if type(port)==type(''):
		port=int(port)
	s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	s.bind((host,port))
	s.listen(1)
	stderr.write(&quot;listening on %s %s\n&quot;%(host,port))
	conn,addr=s.accept()
	stderr.write(&quot;Connection received on %s %s\n&quot;%addr)
	try:
		read=threading.Thread(target=recvdata,args=(conn,))
		read.setDaemon(True)#使线程在主进程结束时终止
		read.start()
		write=threading.Thread(target=senddata,args=(conn,))
		write.setDaemon(True)
		write.start()
		while not event.is_set(): time.sleep(1)
	except KeyboardInterrupt as e:
		conn.close()
		event.set()
		stderr.write(&quot;\n断开连接\n&quot;)

def requester(host,port):
	if type(port)==type(''):
		port=int(port)
	s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	s.connect((host,port))
	stderr.write(&quot;connected to %s %s\n&quot;%(host,port))
	conn=s
	try:
		read=threading.Thread(target=recvdata,args=(conn,))
		read.setDaemon(True)#使线程在主进程结束时终止
		read.start()
		write=threading.Thread(target=senddata,args=(conn,))
		write.setDaemon(True)
		write.start()
		while not event.is_set(): time.sleep(1)
	except KeyboardInterrupt as e:
		conn.close()
		event.set()
		stderr.write(&quot;\n断开连接\n&quot;)
		
def main():
	stderr.write('''Usage:  ./myrequester.py &lt;ip&gt; &lt;port&gt;''')
	if len(argv)==3:
		host,port=argv[1:]
	elif len(argv)==2:
		port=argv[1]
	else:
		host=input(&quot;请输入要请求的ip地址:&quot;)
		if host==&quot;&quot;:
			host=&quot;0.0.0.0&quot;
		port=input(&quot;请输入要请求的端口：&quot;)
	requester(host,port)
	
if __name__=='__main__':
	event=threading.Event()
	main()

</code></pre><p>连上之后它会让你运算 5 次简单运算，输入即给 flag。</p><p>141：让用 python 脚本网络连接，直接用上面的脚本。</p><p>142：让用 c 程序来网络连接，因为 python 打包的程序不能包含 pwnchallenge () 函数，所以老老实实的学了 c 语言的网络连接的方法写了个通过程序：</p><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;


#define PORT 1848
#define SIZE 1024

void pwncollege()&#123;
	return;
&#125;

int ainb(char* a,char* b)&#123;
	long unsigned int len1=strlen(a);
	long unsigned int len2=strlen(b);
	//printf(&quot;len(a):%ld\n&quot;,len1);
	//printf(&quot;len(b):%ld\n&quot;,len2);
	
	if(len1&gt;len2) return 0;
	
	int xflag=0;
	for(int i=0;i&lt;len2-len1;i++)&#123;
		if(strncmp(a,b+i,len1)==0)&#123;
			xflag=1;
			break;
		&#125;
	&#125;
	return xflag;
&#125;

int main(int argc,char* argv[],char* env[])
&#123;
	int client_socket = socket(AF_INET, SOCK_STREAM, 0);   //创建和服务器连接套接字
	if(client_socket == -1)
	&#123;
		perror(&quot;socket&quot;);
		return -1;
	&#125;
	struct sockaddr_in addr;
	memset(&amp;addr, 0, sizeof(addr));
	
	addr.sin_family = AF_INET;  /* Internet地址族 */
    addr.sin_port = htons(PORT);  /* 端口号 */
    addr.sin_addr.s_addr = htonl(INADDR_ANY);   /* IP地址 */
	inet_aton(&quot;127.0.0.1&quot;, &amp;(addr.sin_addr));

	int addrlen = sizeof(addr);
	int listen_socket =  connect(client_socket,  (struct sockaddr *)&amp;addr, addrlen);  //连接服务器
	if(listen_socket == -1)
	&#123;
		perror(&quot;connect&quot;);
		return -1;
	&#125;
	
	printf(&quot;成功连接到一个服务器\n&quot;);
	
	char buf[SIZE] = &#123;0&#125;;
	int ret;
	
	while(1)        //向服务器发送数据，并接收服务器转换后的大写字母
	&#123;
		//读取服务器内容
		//int ret = read(client_socket, buf, strlen(buf));
		while(1)&#123;
			memset(buf, 0, SIZE);//每次读取前重置
			ret = read(client_socket, buf, SIZE);
			printf(&quot;ret = %d\n&quot;, ret);
			if(0&gt;=ret) break;
			printf(&quot;buf = %s&quot;, buf);
			printf(&quot;\n&quot;);
			if(1==ainb(&quot;Please send the solution for: &quot;,buf))
			&#123;
				break;
			&#125;
		&#125;
		
		printf(&quot;请输入你相输入的：&quot;);
		scanf(&quot;%s&quot;, buf);
		write(client_socket, buf, strlen(buf));
		write(client_socket, &quot;\n&quot;, 1);
	&#125;
	close(listen_socket);
	
	return 0;
&#125;

</code></pre></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-10-10 20:22:35" itemprop="dateModified" datetime="2022-10-10T20:22:35+08:00">2022-10-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="lxy WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="lxy Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="lxy PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>lxy <i class="ic i-at"><em>@</em></i>Hello</li><li class="link"><strong>Post link: </strong><a href="http://example.com/2022/05/12/pwn%20college%20%E8%BD%AC/" title="pwncollege">http://example.com/2022/05/12/pwn college 转/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/04/22/%E5%AD%A6%E9%95%BF%E7%9A%84%E6%96%B0%E9%A2%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewf5l51j20zk0m8b29.jpg" title="学长的新题"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>学长的新题</h3></a></div><div class="item right"><a href="/2022/05/12/pwn/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewf5l51j20zk0m8b29.jpg" title="pwn"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>pwn</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2%E5%85%B3%E5%8D%A1%E8%AE%B0%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">0x2. 关卡记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1level1~3%E5%AF%86%E7%A0%81%E4%BC%A0%E5%8F%82"><span class="toc-number">1.1.</span> <span class="toc-text">1.level1~3：密码传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2level47%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.level4，7：环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3level56%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.3.</span> <span class="toc-text">3.level5，6：重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4level8~14shell%E8%84%9A%E6%9C%AC"><span class="toc-number">1.4.</span> <span class="toc-text">4.level8~14：shell 脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5level15~21ipython"><span class="toc-number">1.5.</span> <span class="toc-text">5.level15~21：ipython</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6level22~28python%E8%84%9A%E6%9C%AC"><span class="toc-number">1.6.</span> <span class="toc-text">6.level22~28：python 脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7level29~35c%E8%AF%AD%E8%A8%80"><span class="toc-number">1.7.</span> <span class="toc-text">7.level29~35：c 语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8level36~65%E7%AE%A1%E9%81%93"><span class="toc-number">1.8.</span> <span class="toc-text">8.level36~65：管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9level66~67find%E5%91%BD%E4%BB%A4exec"><span class="toc-number">1.9.</span> <span class="toc-text">9.level66~67：find 命令 exec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10level68~73shell%E8%84%9A%E6%9C%AC%E6%9D%82%E9%A1%B9"><span class="toc-number">1.10.</span> <span class="toc-text">10.level68~73：shell 脚本杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11level74~79python%E8%84%9A%E6%9C%AC%E6%9D%82%E9%A1%B9"><span class="toc-number">1.11.</span> <span class="toc-text">11.level74~79：python 脚本杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12level80~85%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%9D%82%E9%A1%B9"><span class="toc-number">1.12.</span> <span class="toc-text">12.level80~85：子进程杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13level86~87%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="toc-number">1.13.</span> <span class="toc-text">13.level86~87：数据交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14level88~89%E6%94%B9%E5%8F%98argv0"><span class="toc-number">1.14.</span> <span class="toc-text">14.level88~89：改变 argv [0]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15level90~93%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93fifo"><span class="toc-number">1.15.</span> <span class="toc-text">15.level90~93：命名管道 fifo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16level94%E7%BB%91%E5%AE%9A%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6exec"><span class="toc-number">1.16.</span> <span class="toc-text">16.level94：绑定文件描述符 exec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17level95~96%E7%AE%80%E5%8D%95"><span class="toc-number">1.17.</span> <span class="toc-text">17.level95~96：简单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18level97~98%E4%BF%A1%E5%8F%B7signal"><span class="toc-number">1.18.</span> <span class="toc-text">18.level97~98：信号 signal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19level99~111python%E8%84%9A%E6%9C%AC%E6%9D%82%E9%A1%B92"><span class="toc-number">1.19.</span> <span class="toc-text">19.level99~111：python 脚本杂项 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20level112~124c%E8%AF%AD%E8%A8%80%E6%9D%82%E9%A1%B9"><span class="toc-number">1.20.</span> <span class="toc-text">20.level112~124：c 语言杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21level125~139%E4%BA%A4%E4%BA%92%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99"><span class="toc-number">1.21.</span> <span class="toc-text">21.level125~139：交互脚本编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22level140~142%E7%BD%91%E7%BB%9C"><span class="toc-number">1.22.</span> <span class="toc-text">22.level140~142：网络</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="lxy" data-src="/images/avatar.jpg"><p class="name" itemprop="name">lxy</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">21</span> <span class="name">posts</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/04/22/%E5%AD%A6%E9%95%BF%E7%9A%84%E6%96%B0%E9%A2%98/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/05/12/pwn/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2022/01/14/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E6%9C%9F/" title="滴水逆向学习总结第一期">滴水逆向学习总结第一期</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/07/08/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%89%E6%9C%9F/" title="滴水逆向学习总结第三期">滴水逆向学习总结第三期</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/04/17/%E5%85%9A%E8%AF%BE%E7%AC%94%E8%AE%B0/" title="党课笔记">党课笔记</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/07/30/buu-7.30/" title="buu 7.30">buu 7.30</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/07/09/%E6%8C%87%E9%92%88%E4%B8%93%E6%A0%8F/" title="指针专栏">指针专栏</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/03/19/datalab%E5%AE%9E%E9%AA%8C/" title="datalab实验">datalab实验</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/07/09/buu-7.9/" title="buu 7.9">buu 7.9</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/08/06/buu-8.6/" title="buu 8.6">buu 8.6</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/05/12/pwn/" title="pwn">pwn</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/05/12/pwn%20college%20%E8%BD%AC/" title="pwncollege">pwncollege</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">lxy @ li0il Shoka</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/05/12/pwn college 转/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->